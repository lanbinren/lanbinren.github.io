
---
title: 征服C指针
---

使用 printf()输出指针的值时，应使用参数%p。很多人都使用过%x 这样的参数，这种使用方式是错误的。
经常有一种错误的程序写法：使用 NULL 来结束字符串。
将 0 当作空指针来使用，除了极其例外的情况，通常是不会发生错误的。
p[i]是*(p + i)的简便写法。

指向函数的指针”本质上也是指针（地址） ，所以可以将它赋给指针型变量。

int (*func_p)(double); ←指向函数的指针
int (*func_table[])(double); ←指向函数的指针的数组

静态变量是从程序启动到运行结束为止持续存在的变量。因此，静态变量总是在虚拟地址空间上占有固定的区域。


为了在链接器中将名称结合起来，各目标代码大多都具备一个符号表（symbol table） 。可以使用 nm 这样的命令窥视符号表的内容。
> cc -c print_address.c
> nm print_address.o
00000004 b file_static_variable
00000000 T func1
00000000 b func1_static_variable.4
0000002c T func2
00000000 t gcc2_compiled.
00000004 C global_variable
00000048 T main
U malloc
U printf
与全局变量使用 C 进行标记不同的是：和外部没有连接的符号，无论是局部的还是文件内部的 static 变量，都使用了 b 进行标记。
函数名后面追加了 T 或者 U。如果函数是在当前文件中定义的，就在其函数名后加 T；如果函数定义在当前文件之外，只是在当前文件内部调用此函数，就在此函数后面加 U。

C 语言中，通常将自动变量保存在栈中。

assert(条件表达式);  若条件表达式的结果为真，什么也不会发生；若为假，则会输出相关信息并且强制终止程序。

malloc()管理从操作系统一次性地被分配的内存，一般来说调用 free()之后，对应的内存区域是不会立刻返还给操作系统的。之后随着某次 malloc()调用，恰好将这片区域
重新进行分配后，才会发生这部分内容的改写。 

ANSI C 的标准中是不存在这个函数的。就算你使用了 calloc()，在释放内存的时候也请使用 free()。


