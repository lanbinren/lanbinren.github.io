<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo优化]]></title>
    <url>%2F2018%2F12%2F20%2Fhexo%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[优化参考 网站https://segmentfault.com/a/1190000009544924https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html#%E9%99%84%E4%B8%8A%E6%88%91%E7%9A%84-custom-styl 本文结束啦感谢您的阅读 在 \themes\next\layout_macro 新建 passage-end-tag.swig 文件 打开更新文章 时间themes\next_config.yml12345post_meta: item_text: true created_at: true updated_at: true//false categories: true 显示统计字数和估计阅读时长 需要增加如下插件1npm install hexo-wordcount --save Local search1npm install hexo-generator-searchdb --save 使用图床保留图片七牛云 参照修改https://yangbingdong.com/2017/build-blog-hexo-advanced/#%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A01,侧栏加入已运行的时间 背景图片]]></content>
  </entry>
  <entry>
    <title><![CDATA[征服C指针]]></title>
    <url>%2F2018%2F12%2F13%2F%E5%BE%81%E6%9C%8DC%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[使用 printf()输出指针的值时，应使用参数%p。很多人都使用过%x 这样的参数，这种使用方式是错误的。经常有一种错误的程序写法：使用 NULL 来结束字符串。将 0 当作空指针来使用，除了极其例外的情况，通常是不会发生错误的。p[i]是*(p + i)的简便写法。 指向函数的指针”本质上也是指针（地址） ，所以可以将它赋给指针型变量。 int (func_p)(double); ←指向函数的指针int (func_table[])(double); ←指向函数的指针的数组 静态变量是从程序启动到运行结束为止持续存在的变量。因此，静态变量总是在虚拟地址空间上占有固定的区域。 为了在链接器中将名称结合起来，各目标代码大多都具备一个符号表（symbol table） 。可以使用 nm 这样的命令窥视符号表的内容。 cc -c print_address.cnm print_address.o00000004 b file_static_variable00000000 T func100000000 b func1_static_variable.40000002c T func200000000 t gcc2_compiled.00000004 C global_variable00000048 T mainU mallocU printf与全局变量使用 C 进行标记不同的是：和外部没有连接的符号，无论是局部的还是文件内部的 static 变量，都使用了 b 进行标记。函数名后面追加了 T 或者 U。如果函数是在当前文件中定义的，就在其函数名后加 T；如果函数定义在当前文件之外，只是在当前文件内部调用此函数，就在此函数后面加 U。 C 语言中，通常将自动变量保存在栈中。 assert(条件表达式); 若条件表达式的结果为真，什么也不会发生；若为假，则会输出相关信息并且强制终止程序。 malloc()管理从操作系统一次性地被分配的内存，一般来说调用 free()之后，对应的内存区域是不会立刻返还给操作系统的。之后随着某次 malloc()调用，恰好将这片区域重新进行分配后，才会发生这部分内容的改写。 ANSI C 的标准中是不存在这个函数的。就算你使用了 calloc()，在释放内存的时候也请使用 free()。]]></content>
  </entry>
  <entry>
    <title><![CDATA[工作相关问题]]></title>
    <url>%2F2018%2F12%2F13%2F%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Android-P 不能remount问题解决9.0 和 8.0 修改gpio状态指纹初始化失败Android源码 定位问题 Android-P 不能remount问题解决 Android P + kernel-4.9 or after download preloader with verified boot disabled which location is the same as scatter file. //preloader__SBOOT_DIS.bin boot to Home Screen go to setting -&gt; system -&gt; Developer options -&gt; OEM unlocking adb reboot bootloader fastboot flashing unlock press volume up key fastboot reboot adb root adb disable-verity adb reboot adb root adb remount 请注意下载最新的adb/fastboot toolWindowshttps://dl.google.com/android/repository/platform-tools-latest-windows.zipMachttps://dl.google.com/android/repository/platform-tools-latest-darwin.zipLinuxhttps://dl.google.com/android/repository/platform-tools-latest-linux.zip 9.0 和 8.0 修改gpio状态echo mode 31 1 &gt; /sys/devices/platform/1000b000.pinctrl/mt_gpio adb shell echo -w=[pin]:[mode] [pullsel] [din] [dout] [pullen] [dir] [dinv] &gt; /sys/devices/virtual/misc/mtgpio/pin 修改模式 # echo -wmode 63 6 &gt; /sys/class/misc/mtgpio/pin 展讯SL8541E平台（与9832E相似）初始化偶尔·失败·失败时如下图原因是 该ic等待中断时，判断错误，休眠时间不够。 改为休眠250ms。 关掉展讯logecho 1 4 1 7 &gt; /proc/sys/kernel/printk Android源码在线查看http://androidxref.com 指纹比对5次失败之后 修改等待时间/frameworks/base/core/java/android/hardware/fingerprint/FingerprintManager.java1private static final long FAIL_LOCKOUT_TIMEOUT_MS = 30*1000; 密码解锁后，仍在比对状态，追踪上层代码怀疑有多次调用/hardware/interfaces/biometrics/fingerprint/2.1/default/BiometricsFingerprint.cpp123456789101112131415161718/** * Retrieves the authenticator token for binding keys to the lifecycle * of the calling user's fingerprints. Used only by internal clients. * * @hide */ public long getAuthenticatorId() &#123; if (mService != null) &#123; try &#123; return mService.getAuthenticatorId(mContext.getOpPackageName()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; else &#123; Slog.w(TAG, "getAuthenticatorId(): Service not connected!"); &#125; return 0; &#125; 自动生成权限audit2allow -i sepolicy.log 1234567891011121314151617181920sepolicy.log01-01 00:06:32.939 4717 4717 I android.hardwar: type=1400 audit(0.0:133): avc: denied &#123; read write &#125; for name="vndbinder" dev="tmpfs" ino=16186 scontext=u:r:hal_fingerprint_default:s0 tcontext=u:object_r:vndbinder_device:s0 tclass=chr_file permissive=101-01 00:06:32.939 4717 4717 I android.hardwar: type=1400 audit(0.0:134): avc: denied &#123; open &#125; for path="/dev/vndbinder" dev="tmpfs" ino=16186 scontext=u:r:hal_fingerprint_default:s0 tcontext=u:object_r:vndbinder_device:s0 tclass=chr_file permissive=101-01 00:06:32.939 4717 4717 I android.hardwar: type=1400 audit(0.0:135): avc: denied &#123; ioctl &#125; for path="/dev/vndbinder" dev="tmpfs" ino=16186 ioctlcmd=6209 scontext=u:r:hal_fingerprint_default:s0 tcontext=u:object_r:vndbinder_device:s0 tclass=chr_file permissive=101-01 00:06:32.949 4717 4717 I android.hardwar: type=1400 audit(0.0:136): avc: denied &#123; call &#125; for scontext=u:r:hal_fingerprint_default:s0 tcontext=u:r:vndservicemanager:s0 tclass=binder permissive=101-01 00:06:32.949 4717 4717 I android.hardwar: type=1400 audit(0.0:137): avc: denied &#123; transfer &#125; for scontext=u:r:hal_fingerprint_default:s0 tcontext=u:r:vndservicemanager:s0 tclass=binder permissive=101-01 00:06:32.949 444 444 I vndservicemanag: type=1400 audit(0.0:138): avc: denied &#123; search &#125; for name="4717" dev="proc" ino=45591 scontext=u:r:vndservicemanager:s0 tcontext=u:r:hal_fingerprint_default:s0 tclass=dir permissive=101-01 00:06:32.949 444 444 I vndservicemanag: type=1400 audit(0.0:139): avc: denied &#123; read &#125; for name="current" dev="proc" ino=44817 scontext=u:r:vndservicemanager:s0 tcontext=u:r:hal_fingerprint_default:s0 tclass=file permissive=101-01 00:06:32.949 444 444 I vndservicemanag: type=1400 audit(0.0:140): avc: denied &#123; open &#125; for path="/proc/4717/attr/current" dev="proc" ino=44817 scontext=u:r:vndservicemanager:s0 tcontext=u:r:hal_fingerprint_default:s0 tclass=file permissive=101-01 00:06:32.949 444 444 I vndservicemanag: type=1400 audit(0.0:141): avc: denied &#123; getattr &#125; for scontext=u:r:vndservicemanager:s0 tcontext=u:r:hal_fingerprint_default:s0 tclass=process permissive=101-01 00:06:32.949 4720 4720 I android.hardwar: type=1400 audit(0.0:142): avc: denied &#123; execute_no_trans &#125; for path="/vendor/bin/sf_ta" dev="mmcblk0p25" ino=280 scontext=u:r:hal_fingerprint_default:s0 tcontext=u:object_r:vendor_file:s0 tclass=file permissive=101-01 00:06:32.989 4720 4720 I sf_ta : type=1400 audit(0.0:143): avc: denied &#123; call &#125; for scontext=u:r:hal_fingerprint_default:s0 tcontext=u:r:hal_fingerprint_default:s0 tclass=binder permissive=101-01 00:06:33.039 4720 4720 I sf_ta : type=1400 audit(0.0:144): avc: denied &#123; read write &#125; for name="sunwave_fp" dev="tmpfs" ino=16210 scontext=u:r:hal_fingerprint_default:s0 tcontext=u:object_r:device:s0 tclass=chr_file permissive=101-01 00:06:33.039 4720 4720 I sf_ta : type=1400 audit(0.0:145): avc: denied &#123; open &#125; for path="/dev/sunwave_fp" dev="tmpfs" ino=16210 scontext=u:r:hal_fingerprint_default:s0 tcontext=u:object_r:device:s0 tclass=chr_file permissive=101-01 00:06:33.039 4720 4720 I sf_ta : type=1400 audit(0.0:146): avc: denied &#123; ioctl &#125; for path="/dev/sunwave_fp" dev="tmpfs" ino=16210 ioctlcmd=730b scontext=u:r:hal_fingerprint_default:s0 tcontext=u:object_r:device:s0 tclass=chr_file permissive=101-01 00:06:33.049 4717 4717 I android.hardwar: type=1400 audit(0.0:147): avc: denied &#123; create &#125; for scontext=u:r:hal_fingerprint_default:s0 tcontext=u:r:hal_fingerprint_default:s0 tclass=netlink_kobject_uevent_socket permissive=101-01 00:06:33.049 4717 4717 I android.hardwar: type=1400 audit(0.0:148): avc: denied &#123; setopt &#125; for scontext=u:r:hal_fingerprint_default:s0 tcontext=u:r:hal_fingerprint_default:s0 tclass=netlink_kobject_uevent_socket permissive=101-01 00:06:33.049 4717 4717 I android.hardwar: type=1400 audit(0.0:149): avc: denied &#123; bind &#125; for scontext=u:r:hal_fingerprint_default:s0 tcontext=u:r:hal_fingerprint_default:s0 tclass=netlink_kobject_uevent_socket permissive=101-01 00:07:00.489 4720 4720 I sf_ta : type=1400 audit(0.0:152): avc: denied &#123; ioctl &#125; for path="/dev/sunwave_fp" dev="tmpfs" ino=16210 ioctlcmd=730b scontext=u:r:hal_fingerprint_default:s0 tcontext=u:object_r:device:s0 tclass=chr_file permissive=1 123456789101112131415# audit2allow -i sepolicy.log#============= hal_fingerprint_default ==============allow hal_fingerprint_default device:chr_file &#123; read write ioctl open &#125;;allow hal_fingerprint_default self:binder call;allow hal_fingerprint_default self:netlink_kobject_uevent_socket &#123; bind create setopt &#125;;allow hal_fingerprint_default vendor_file:file execute_no_trans;allow hal_fingerprint_default vndbinder_device:chr_file &#123; ioctl open &#125;;allow hal_fingerprint_default vndservicemanager:binder &#123; transfer call &#125;;#============= vndservicemanager ==============allow vndservicemanager hal_fingerprint_default:dir search;allow vndservicemanager hal_fingerprint_default:file &#123; read open &#125;;allow vndservicemanager hal_fingerprint_default:process getattr;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 宝石与石头]]></title>
    <url>%2F2018%2F12%2F13%2Fleetcode%2F</url>
    <content type="text"><![CDATA[宝石与石头给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。 int numJewelsInStones(char J, char S) {int list[‘z’-‘A’+1]={0},sum=0,i=0;while(S[i]!=’\0’){ list[S[i]-‘A’]++; i++;}i = 0;while(J[i]!=’\0’){ sum+=list[J[i]-‘A’]; i++;}return sum;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[git命令]]></title>
    <url>%2F2018%2F12%2F13%2Fgit%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git init 初始化 Git 库ssh验证指令生成 SSH 也是唯一一个同时便于读和写操作的网络协议。 生成所在路径/root/.ssh/。 ssh-keygen -t rsa -C “your_email@youremail.com“ git clone git@github.com:lanbinren/test.git 拉取分支 git clone git@github.com:lanbinren/test.git xxx 指定生成路径到xxx git status 检查当前文件状态 ，会看到 README 文件已被跟踪，并处于暂存状态。 git diff 显示还没有暂存起来的改动，而不是这次工作和上次提交之间的差异。git diff --cached 查看暂存起来的文件和上次提交时的快照之间的差异。 git commit -v 选项将修改差异的每一行都包含到注释中来。 （常用）-m 参数后跟提交说明 。 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤。 git commit --amend 修改最后一次提交。 git reset HEAD 取消暂存。 git remote 查看当前配置有哪些远程仓库git remote -v 可以加上 -v 选项（译注：此为—verbose 的简写，取首字母），显示对应的克隆地址。 git fetch 只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。 git pull 是从原始克隆的远端仓库中抓取数据后，合并到工作目录中当前分支。 git-push 可将本地版本更新推送到远端仓库中。 git commit --amend 修改最后一次提交 ####查看提交历史 git log --stat 列出了修改过的文件，以及其中添加和移除的行数，并在最后列出所有增减行数小计。 git log --since=2.weeks 显示两周以前的记录。 选项 说明-(n) 仅显示最近的 n 条提交--since, --after 仅显示指定时间之后的提交。--until, --before 仅显示指定时间之前的提交。--author 仅显示指定作者相关的提交。--committer 仅显示指定提交者相关的提交。 git log --pretty=format:”%h - %an, %ar : %s” 可以定制要显示的记录格式 。 $ git log --pretty=format:”%h - %an, %ar : %s”ca82a6d - Scott Chacon, 11 months ago : changed the verison number085bb3b - Scott Chacon, 11 months ago : removed unnecessary test codea11bef0 - Scott Chacon, 11 months ago : first commit 表 2.1 列出了常用的格式占位符写法及其代表的意义。|选项 |说明|| :--: | :--: ||%H | 提交对象（commit）的完整哈希字串||%h | 提交对象的简短哈希字串||%T | 树对象（tree）的完整哈希字串||%t | 树对象的简短哈希字串||%P | 父对象（parent）的完整哈希字串||%p | 父对象的简短哈希字串||%an |作者（author）的名字||%ae | 作者的电子邮件地址||%ad |作者修订日期（可以用 -date= 选项定制格式）||%ar |作者修订日期，按多久以前的方式显示||%cn |提交者(committer)的名字||%ce |提交者的电子邮件地址||%cd |提交日期||%cr |提交日期，按多久以前的方式显示||%s |提交说明| ####标签 git tag 列出当前标签 git tag -a v0.0 -m ‘my version 0.0’ 创建一个含附注类型的标签 后期加注标签git log --pretty=oneline 用一行展示的提交历史git tag -a v1.2 9fceb02 只要在打标签的时候跟上对应提交对象的校验和（或前几位字符）即可。 默认情况下， git push 并不会把标签传送到远端服务器上 git push origin [tagname]. 如果要一次推送所有（本地新增的）标签上去，可以使用 --tags 选项 git push origin --tags。 ####Git 命令别名 $ git config --global alias.unstage ‘reset HEAD --‘ 这样一来，下面的两条命令完全等同： $ git unstage fileA$ git reset HEAD fileAgit checkout -- benchmarks.rb 从服务器端重新下载。 使用 git config --global core.editor 命令 设定 编辑器。 仓库创建后…or create a new repository on the command line echo “# My-HEXO” &gt;&gt; README.mdgit initgit add README.mdgit commit -m “first commit”git remote add origin git@github.com:lanbinren/My-HEXO.gitgit push -u origin master …or push an existing repository from the command line git remote add origin git@github.com:lanbinren/My-HEXO.git git pull origin master –allow-unrelated-histories 后面加上 –allow-unrelated-histories ， 把两段不相干的 分支进行强行合并 将hexo源码 放到分支提交文件到暂存区git add –allgit commit -m “hexo原生数据” git clone -b hexo https://github.com/lanbinren/lanbinren.github.io.git 设置本地分支追踪远程分支git push –set-upstream origin hexo]]></content>
  </entry>
  <entry>
    <title><![CDATA[First Test]]></title>
    <url>%2F2018%2F12%2F13%2FFirstNight%2F</url>
    <content type="text"><![CDATA[SPI（Serial Peripheral Interface）总线是主要应用于嵌入式系统内部通信的串行同步传输总线协议。通常为四线制的SPI总线支持全双工通信。SPI最初由Motorola在2000年提出，Motorola所定义的SPI标准为业界广泛引用，但不同半导体公司的实施细节可能有所不同，这些区别体现在寄存器设置、信号定义、数据格式等。业界没有统一的SPI标准，具体应用需要参考特定器件手册。 SPI协议特点包括主从模式、全双工通信、片选功能、模式错误标识及CPU中断、缓冲数据寄存器和可配置时钟相位极性等。SPI允许数据一位一位的传送，甚至允许暂停，因为SCK时钟线由主控设备控制，当没有时钟跳变时，从设备不采集或传送数据。也就是说，主设备通过对SCK时钟线的控制可以完成对通讯的控制。 应用SPI以其简单高效应用于绝大多数SoC系统上，这些SoC通常同时支持作为主模式或从模式（二选一）。 FPGAs和其它专用芯片也广泛使用SPI传输数据。比如： . 传感器：温度、压力传感器等. 控制设备：音频编解码器等. 通信设备：USB、以太网设备等. 存储器：Flash、EEPROM等. RTC时钟. LCD设备. MMC和SD卡 在高性能系统中，FPGAs通常使用SPI连接主从设备，比如连接外部传感器，和应用SPI加载配置。相比于JTAG，SPI定位用于高速配置（初始化）板上设备；而JTAG的初衷是为控制设备以相对低的准确度扫描和检测板上IO，在严格要求的场合，JTAG协议支持改变时钟占空比以满足建立和保持时间的要求。因此，JTAG并不定位于高速数据传输的场合。 优点和缺点 优点支持全双工通信Push-Pull驱动性能相比Open Drain信号完整性更好，支持高速应用（100MHz以上）协议支持字长不限于8bits，可根据应用特点灵活选择消息字长硬件连接简单 . 只需要四根信号线（部分应用可以缩减到三根）. 相比I2C和SMbus节省上拉电阻. 相比I2C和SMbus不需要仲裁机制. 从设备使用主设备时钟，节约时钟要求. 从设备无需地址寻址. 无需收发器 缺点相比I2C两根线，SPI四根线更多没有寻址机制，只能靠设备片选（chip select）选择不同从设备没有数据流控制（但主设备可以通过延缓时钟边缘降低传输速度）没有从设备接收数据ACK，主设备对于发送成功与否不得而知典型应用只支持单主控没有定义数据校验机制没有统一的国际组织维护，变种多不利于不同厂商设备的互操作性（interoperability）相比于RS232、RS422、RS485和CAN，SPI传输距离短不支持热插拔中断操作只能通过额外的信号线，或类似USB 1.1 and 2.0的Periodic Polling实现]]></content>
  </entry>
  <entry>
    <title><![CDATA[ANDROID核心原理与系统应用高效开发]]></title>
    <url>%2F2018%2F12%2F13%2FANDROID%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[第一章 系统框架结构和启动流程 从事Android 设备硬件移植方面的开发，需要对Linux 语言开发有较深的了解1234通信部分和具体硬件相关子系统结构相结合，了解一个硬件如何适配于Android系统。启动流程了解硬件优化方面的知识GUI系统提供Android系统适配于非手机设备的相关知识安全系统方面了解 新增硬件的安全管理]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F02%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
